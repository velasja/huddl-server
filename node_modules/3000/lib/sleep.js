/**
 * Sleep constructor implemented with setTimeout.
 */
function AsyncSleep() {
    var self = this;
    var D = 0;
    var F = 1;
    self.locked = false;
    self.actions = [];
    self.tryLock = function() {
        if (self.locked) {
            return false;
        } else {
            self.locked = true;
            return true;
        }
    };
    self.tryFinish = function() {
        if (self.actions.length === 0) {
            self.locked = false;
            return true;
        } else {
            return false;
        }

    };
    self.run = function() {
        if (!self.tryFinish()) {
            var action = self.actions.shift();
            var d = action[0];
            var f = action[1];
            self.sleeping = setTimeout(() => {
                f();
                self.run();
            }, d);
        }
        return self;
    };
    self.sleep = function(d, f) {
        if (typeof(d) === 'number' && typeof(f) === 'function') {
            self.actions.push([d, f]);
        }
        if (self.tryLock()) {
            self.run();
        }
        return self;
    };
    self.clear = function() {
        self.actions = [];
        if (typeof(self.sleeping) !== 'undefined') {
            clearTimeout(self.sleeping);
        }
        return self.tryFinish();
    };
}

/**
 * A sleep function implemented with busy for loop.
 */
function busyLoopSleep(d) {
    for (let t = Date.now(); Date.now() - t <= d;);
}

module.exports.asleep = AsyncSleep;
module.exports.bsleep = busyLoopSleep;

/**
 * A sleep function implemented with C++ addon.
 */
try {
    module.exports.csleep = require('../build/Release/addon.node').sleep;
} catch (err) {
    process.stderr.write('failed loading native sleep, using busy loop version instead.\n');
    module.exports.csleep = busyLoopSleep;
}
